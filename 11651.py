import sys

N = int(sys.stdin.readline())
loc =[0] * N 

for i in range(0,N):
    x,y = map(int, sys.stdin.readline().split())
    loc[i] = [x,y]

loc.sort(key=lambda x: (x[1], x[0]))
# 1번 인덱스에 대해서 먼저 정렬을 진행한 뒤,
# 0번 인덱스를 정렬한다. 
# -> 0 4가 맨 뒤에 나오기에 1번째 인덱스에서부터 정렬을 진행

for j in range(len(loc)):
    print(loc[j][0], loc[j][1])

'''
2차원 배열에서의 정렬
- 첫번째 값 이용
    lst = [[2, 1], [3, 4], [1, 2], [1, 3], [3, 2]]
    lst.sort(key=lambda x:x[0])
    print(lst)

    # [[1, 2], [1, 3], [2, 1], [3, 4], [3, 2]]
    -> lambda를 사용하여 x:x[0] 으로 0번째 인덱스에 대해서 정렬
        0번째 인덱스에 대해서 오름차순으로 정렬을 진행,
        1번째 인덱스에 대해서는 정렬이 되지 않는다.

- 두번째 값 이용
    lst = [[2, 1], [3, 4], [1, 2], [1, 3], [3, 2]]
    lst.sort(key=lambda x: (x[0], -x[1]))
    print(lst)

    # [[1, 3], [1, 2], [2, 1], [3, 4], [3, 2]]
    -> x: () 처럼 괄호안에 튜플 형식으로 집어넣는다.
        이때 -를 하면 역으로 정렬시킬 수 있다고한다.
        위 예제의 경우, 먼저 0번 인덱스에 대해서 오름차순으로 정렬하고
        동일한 값의 경우 내림차순으로 재정렬한다고한다.
    ---------------------------------------------------------------

    lst = [[2, 1], [3, 4], [1, 2], [1, 3], [3, 2]]
    lst.sort(key=lambda x: (x[1], x[0]))
    print(lst)

    # [[2, 1], [1, 2], [3, 2], [1, 3], [3, 4]]  
    -> 순서바꾸어 정렬도 가능.
        위 예제는 1번 인덱스에 대해서 먼저 오름차순으로 정렬을 진행하고   
        같은 1번인덱스의 경우 0번째 인덱스에 대해서 오름차순으로 정렬을 진행한다.
    ---------------------------------------------------------------

    2차원 배열에서 sort의 기본은 
    0번째 인덱스를 오름차순으로 정렬하고, 1번째 인덱스를 오름차순으로 정렬한다.
    특정 인덱스에 대해 정렬하려면 key를 사용해야한다.
'''